package uk.ac.imperial.lpgdash

import java.util.List
import java.util.ArrayList

import uk.ac.imperial.lpgdash.ProvisionPool
import uk.ac.imperial.lpgdash.actions.*
import uk.ac.imperial.lpgdash.facts.*
import uk.ac.imperial.lpgdash.RoundType
import uk.ac.imperial.lpgdash.allocators.LegitimateClaims

global org.apache.log4j.Logger logger

declare LoggedHistory
	@role( event )
	act: Object @key
end

query lcCluster(Cluster c)
	Cluster( this == c, allocationMethod in (
		Allocation.LC_FIXED,
		Allocation.LC_F1,
		Allocation.LC_F1a,
		Allocation.LC_F2,
		Allocation.LC_F3,
		Allocation.LC_F4,
		Allocation.LC_F5,
		Allocation.LC_F6,
		Allocation.LC_F7,
		Allocation.LC_SO ) )
end

query compliantRound(Cluster c, Player p, int $t)
	MemberOf( player == p, cluster == c )
	Generate( t == $t, $g : g, $q : q, player == p )
	Demand( $d : quantity, player == p, t == $t, quantity == $q )
	Provision( $p : quantity, player == p, t == $t, quantity == $g )
	Allocate( $r : quantity, player == p, t == $t )
	Appropriate( $rP : quantity, player == p, t == $t, quantity == $r )
end

rule "Create PlayerHistory"
	salience 2
	when
		MemberOf( $p : player, $c : cluster )
		lcCluster( $c ;)
		Player( this == $p, getHistory()[$c] == null )
	then
		modify( $p ) {
			getHistory().put( $c, new PlayerHistory( ) )
		}
end

rule "Update allocation history new"
	when
		JoinCluster( $p : player, $c : cluster, $t : t)
		not LeaveCluster( cluster == $c, player == $p, $t < t )
		MemberOf( player == $p, cluster == $c )
		lcCluster( $c ;)
		$a : Allocate( player == $p, $q : quantity, $t < t )
		not LoggedHistory( $a ;)
	then
		PlayerHistory hist = $p.getHistory().get($c);
		hist.allocations.addValue( $q );
		if($q > 0)
			hist.incrementRoundsAllocated();
		insert( new LoggedHistory( $a ) );
end

/*rule "Update demand history"
	when
		$joined : JoinCluster( $p : player, $c : cluster )
		lcCluster( $c ;)
		MemberOf( player == $p, cluster == $c )
		not LeaveCluster( cluster == $c, player == $p )
		accumulate( Demand( player == $p, this after $joined, $q : quantity ), 
			$demanded	: average($q)
		)
	then
		modify( $p ) {
			getHistory().get($c).setAverageDemanded( $demanded.doubleValue() )
		}
end*/

rule "Update demand history new"
	when
		JoinCluster( $p : player, $c : cluster, $t : t)
		not LeaveCluster( cluster == $c, player == $p, $t < t )
		MemberOf( player == $p, cluster == $c )
		lcCluster( $c ;)
		$d : Demand( player == $p, $q : quantity, $t < t )
		not LoggedHistory( $d ;)
	then
		PlayerHistory hist = $p.getHistory().get($c);
		hist.demands.addValue( $q );
		insert( new LoggedHistory( $d ) );
		//logger.info( "Average Demand: "+ hist.demands.getMean() +", "+ $p );
end

/*rule "Update provision history"
	when
		$joined : JoinCluster( $p : player, $c : cluster )
		lcCluster( $c ;)
		MemberOf( player == $p, cluster == $c )
		not LeaveCluster( cluster == $c, player == $p )
		accumulate( Provision( player == $p, this after $joined, $q : quantity ), 
			$provided	: average($q),
			$rounds		: count($q)
		)
	then
		modify( $p ) {
			getHistory().get($c).setAverageProvided( $provided.doubleValue() ),
			getHistory().get($c).setRoundsParticipated( $rounds.intValue() )
		}
end*/

rule "Update provision history new"
	when
		JoinCluster( $p : player, $c : cluster, $t : t)
		not LeaveCluster( cluster == $c, player == $p, $t < t )
		MemberOf( player == $p, cluster == $c )
		lcCluster( $c ;)
		$d : Provision( player == $p, $q : quantity, $t < t )
		not LoggedHistory( $d ;)
	then
		PlayerHistory hist = $p.getHistory().get($c);
		hist.provisions.addValue( $q );
		hist.incrementRoundsParticipated();
		insert( new LoggedHistory( $d ) );
		//logger.info( "Average Provision: "+ hist.provisions.getMean() +", "+ $p );
		//logger.info( "Rounds participated: "+ hist.getRoundsParticipated() +", "+ $p );
end

/*rule "Count rounds as head"
	no-loop
	when
		$joined : JoinCluster( $p : player, $c : cluster )
		lcCluster( $c ;)
		MemberOf( player == $p, cluster == $c )
		not LeaveCluster( cluster == $c, player == $p )
		accumulate( $e : IsHead( player == $p, cluster == $c, this after $joined ), 
			$rounds		: count($e)
		)
	then
		modify( $p ) {
			getHistory().get($c).setRoundsAsHead( $rounds.intValue() )
		}
end*/

rule "Count rounds as head new"
	when
		JoinCluster( $p : player, $c : cluster, $t : t)
		not LeaveCluster( cluster == $c, player == $p, $t < t )
		MemberOf( player == $p, cluster == $c )
		lcCluster( $c ;)
		$h : IsHead( player == $p, cluster == $c, $t < time )
		not LoggedHistory( $h ;)
	then
		PlayerHistory hist = $p.getHistory().get($c);
		hist.incrementRoundsAsHead();
		insert( new LoggedHistory( $h ) );
		//logger.info( "Rounds as head: "+ hist.getRoundsAsHead() +", "+ $p );
end

/*rule "Count compliant rounds"
	when
		$joined : JoinCluster( $player : player, $c : cluster, $tJoined : t )
		lcCluster( $c ;)
		MemberOf( player == $player, cluster == $c )
		not LeaveCluster( cluster == $c, player == $player )
		accumulate(
			Generate( $t : t, $g : g, $q : q, player == $player, t >= $tJoined )
			and
			Demand( $d : quantity, player == $player, t == $t, quantity == $q )
			and
			Provision( $p : quantity, player == $player, t == $t, quantity == $g )
			and
			Allocate( $r : quantity, player == $player, t == $t )
			and
			Appropriate( $rP : quantity, player == $player, t == $t, quantity == $r )
			,
			$rounds : count( $t )
		)
	then
		modify( $player ) {
			getHistory().get($c).setCompliantRounds( $rounds.intValue() )
		}
end*/

rule "Count compliant rounds new"
	when
		JoinCluster( $p : player, $c : cluster, $tJoin : t)
		not LeaveCluster( cluster == $c, player == $p, $tJoin < t )
		MemberOf( player == $p, cluster == $c )
		lcCluster( $c ;)
		Round( $t : number, type == RoundType.APPROPRIATE )
		compliantRound( $c , $p, $t ;) 
	then
		PlayerHistory hist = $p.getHistory().get($c);
		hist.incrementCompliantRounds();
		//logger.info( "Compliant rounds: "+ hist.getCompliantRounds() +", "+ $p );
end

rule "Calculate satisfaction from previous round"
	when
		MemberOf( $player : player, $c : cluster )
		lcCluster( $c ;)
		Round( $t : number, type == RoundType.DEMAND )
		Generate( $g : g, $q : q, player == $player, t == $t-1 )
		Demand( $d : quantity, player == $player, t == $t-1 )
		Provision( $p : quantity, player == $player, t == $t-1 )
		Appropriate( $r : quantity, player == $player, t == $t-1 )
	then
		PlayerHistory hist = $player.getHistory().get($c);
		double s = hist.getSatisfaction();
		double R = $r + ( $g - $p );
		if( R >= $q ) {
			s = s + $player.getAlpha() * (1 - s);
		} else {
			s = s - $player.getBeta() * s;
		}
		hist.setSatisfaction(s);
end

rule "LC resource allocation"
	no-loop
	salience -2
	when
		$r : Round( type == RoundType.DEMAND, $t : number, $tm : number - 1 )
		not Processed( $r ;)
		$c : Cluster( $method : allocationMethod )
		lcCluster( $c ;)
		$pool : ProvisionPool( cluster == $c )
		$poolMembers : List(size > 0) from accumulate( MemberOf( cluster == $c, $p : player ), collectList( $p ) )
		$lc : LegitimateClaims( c == $c )
	then
		logger.info( $method +" allocation for resources " + $c);
		$lc.allocate($poolMembers, $pool.getQuantity(), $t );
		modify( $pool ) {
			setQuantity(0);
		}
		insert( new Processed( $r ) );
end
